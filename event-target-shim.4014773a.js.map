{"version":3,"sources":["../src/event.mjs","../src/event-target.mjs"],"names":[],"mappings":"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","file":"event-target-shim.4014773a.js","sourceRoot":"../demo","sourcesContent":["/**\n * @typedef {object} PrivateData\n * @property {EventTarget} eventTarget The event target.\n * @property {{type:string}} event The original event object.\n * @property {number} eventPhase The current event phase.\n * @property {EventTarget|null} currentTarget The current event target.\n * @property {boolean} canceled The flag to prevent default.\n * @property {boolean} stopped The flag to stop propagation.\n * @property {boolean} immediateStopped The flag to stop propagation immediately.\n * @property {Function|null} passiveListener The listener if the current listener is passive. Otherwise this is null.\n * @property {number} timeStamp The unix time.\n * @private\n */\n\n/**\n * Private data for event wrappers.\n * @type {WeakMap<Event, PrivateData>}\n * @private\n */\nconst privateData = new WeakMap()\n\n/**\n * Cache for wrapper classes.\n * @type {WeakMap<Object, Function>}\n * @private\n */\nconst wrappers = new WeakMap()\n\n/**\n * Get private data.\n * @param {Event} event The event object to get private data.\n * @returns {PrivateData} The private data of the event.\n * @private\n */\nfunction pd(event) {\n    const retv = privateData.get(event)\n    console.assert(\n        retv != null,\n        \"'this' is expected an Event object, but got\",\n        event\n    )\n    return retv\n}\n\n/**\n * https://dom.spec.whatwg.org/#set-the-canceled-flag\n * @param data {PrivateData} private data.\n */\nfunction setCancelFlag(data) {\n    if (data.passiveListener != null) {\n        if (\n            typeof console !== \"undefined\" &&\n            typeof console.error === \"function\"\n        ) {\n            console.error(\n                \"Unable to preventDefault inside passive event listener invocation.\",\n                data.passiveListener\n            )\n        }\n        return\n    }\n    if (!data.event.cancelable) {\n        return\n    }\n\n    data.canceled = true\n    if (typeof data.event.preventDefault === \"function\") {\n        data.event.preventDefault()\n    }\n}\n\n/**\n * @see https://dom.spec.whatwg.org/#interface-event\n * @private\n */\n/**\n * The event wrapper.\n * @constructor\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Event|{type:string}} event The original event to wrap.\n */\nfunction Event(eventTarget, event) {\n    privateData.set(this, {\n        eventTarget,\n        event,\n        eventPhase: 2,\n        currentTarget: eventTarget,\n        canceled: false,\n        stopped: false,\n        immediateStopped: false,\n        passiveListener: null,\n        timeStamp: event.timeStamp || Date.now(),\n    })\n\n    // https://heycam.github.io/webidl/#Unforgeable\n    Object.defineProperty(this, \"isTrusted\", { value: false, enumerable: true })\n\n    // Define accessors\n    const keys = Object.keys(event)\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i]\n        if (!(key in this)) {\n            Object.defineProperty(this, key, defineRedirectDescriptor(key))\n        }\n    }\n}\n\n// Should be enumerable, but class methods are not enumerable.\nEvent.prototype = {\n    /**\n     * The type of this event.\n     * @type {string}\n     */\n    get type() {\n        return pd(this).event.type\n    },\n\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     */\n    get target() {\n        return pd(this).eventTarget\n    },\n\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     */\n    get currentTarget() {\n        return pd(this).currentTarget\n    },\n\n    /**\n     * @returns {EventTarget[]} The composed path of this event.\n     */\n    composedPath() {\n        const currentTarget = pd(this).currentTarget\n        if (currentTarget == null) {\n            return []\n        }\n        return [currentTarget]\n    },\n\n    /**\n     * Constant of NONE.\n     * @type {number}\n     */\n    get NONE() {\n        return 0\n    },\n\n    /**\n     * Constant of CAPTURING_PHASE.\n     * @type {number}\n     */\n    get CAPTURING_PHASE() {\n        return 1\n    },\n\n    /**\n     * Constant of AT_TARGET.\n     * @type {number}\n     */\n    get AT_TARGET() {\n        return 2\n    },\n\n    /**\n     * Constant of BUBBLING_PHASE.\n     * @type {number}\n     */\n    get BUBBLING_PHASE() {\n        return 3\n    },\n\n    /**\n     * The target of this event.\n     * @type {number}\n     */\n    get eventPhase() {\n        return pd(this).eventPhase\n    },\n\n    /**\n     * Stop event bubbling.\n     * @returns {void}\n     */\n    stopPropagation() {\n        const data = pd(this)\n\n        data.stopped = true\n        if (typeof data.event.stopPropagation === \"function\") {\n            data.event.stopPropagation()\n        }\n    },\n\n    /**\n     * Stop event bubbling.\n     * @returns {void}\n     */\n    stopImmediatePropagation() {\n        const data = pd(this)\n\n        data.stopped = true\n        data.immediateStopped = true\n        if (typeof data.event.stopImmediatePropagation === \"function\") {\n            data.event.stopImmediatePropagation()\n        }\n    },\n\n    /**\n     * The flag to be bubbling.\n     * @type {boolean}\n     */\n    get bubbles() {\n        return Boolean(pd(this).event.bubbles)\n    },\n\n    /**\n     * The flag to be cancelable.\n     * @type {boolean}\n     */\n    get cancelable() {\n        return Boolean(pd(this).event.cancelable)\n    },\n\n    /**\n     * Cancel this event.\n     * @returns {void}\n     */\n    preventDefault() {\n        setCancelFlag(pd(this))\n    },\n\n    /**\n     * The flag to indicate cancellation state.\n     * @type {boolean}\n     */\n    get defaultPrevented() {\n        return pd(this).canceled\n    },\n\n    /**\n     * The flag to be composed.\n     * @type {boolean}\n     */\n    get composed() {\n        return Boolean(pd(this).event.composed)\n    },\n\n    /**\n     * The unix time of this event.\n     * @type {number}\n     */\n    get timeStamp() {\n        return pd(this).timeStamp\n    },\n\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     * @deprecated\n     */\n    get srcElement() {\n        return pd(this).eventTarget\n    },\n\n    /**\n     * The flag to stop event bubbling.\n     * @type {boolean}\n     * @deprecated\n     */\n    get cancelBubble() {\n        return pd(this).stopped\n    },\n    set cancelBubble(value) {\n        if (!value) {\n            return\n        }\n        const data = pd(this)\n\n        data.stopped = true\n        if (typeof data.event.cancelBubble === \"boolean\") {\n            data.event.cancelBubble = true\n        }\n    },\n\n    /**\n     * The flag to indicate cancellation state.\n     * @type {boolean}\n     * @deprecated\n     */\n    get returnValue() {\n        return !pd(this).canceled\n    },\n    set returnValue(value) {\n        if (!value) {\n            setCancelFlag(pd(this))\n        }\n    },\n\n    /**\n     * Initialize this event object. But do nothing under event dispatching.\n     * @param {string} type The event type.\n     * @param {boolean} [bubbles=false] The flag to be possible to bubble up.\n     * @param {boolean} [cancelable=false] The flag to be possible to cancel.\n     * @deprecated\n     */\n    initEvent() {\n        // Do nothing.\n    },\n}\n\n// `constructor` is not enumerable.\nObject.defineProperty(Event.prototype, \"constructor\", {\n    value: Event,\n    configurable: true,\n    writable: true,\n})\n\n// Ensure `event instanceof window.Event` is `true`.\nif (typeof window !== \"undefined\" && typeof window.Event !== \"undefined\") {\n    Object.setPrototypeOf(Event.prototype, window.Event.prototype)\n\n    // Make association for wrappers.\n    wrappers.set(window.Event.prototype, Event)\n}\n\n/**\n * Get the property descriptor to redirect a given property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to redirect the property.\n * @private\n */\nfunction defineRedirectDescriptor(key) {\n    return {\n        get() {\n            return pd(this).event[key]\n        },\n        set(value) {\n            pd(this).event[key] = value\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}\n\n/**\n * Get the property descriptor to call a given method property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to call the method property.\n * @private\n */\nfunction defineCallDescriptor(key) {\n    return {\n        value() {\n            const event = pd(this).event\n            return event[key].apply(event, arguments)\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}\n\n/**\n * Define new wrapper class.\n * @param {Function} BaseEvent The base wrapper class.\n * @param {Object} proto The prototype of the original event.\n * @returns {Function} The defined wrapper class.\n * @private\n */\nfunction defineWrapper(BaseEvent, proto) {\n    const keys = Object.keys(proto)\n    if (keys.length === 0) {\n        return BaseEvent\n    }\n\n    /** CustomEvent */\n    function CustomEvent(eventTarget, event) {\n        BaseEvent.call(this, eventTarget, event)\n    }\n\n    CustomEvent.prototype = Object.create(BaseEvent.prototype, {\n        constructor: { value: CustomEvent, configurable: true, writable: true },\n    })\n\n    // Define accessors.\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i]\n        if (!(key in BaseEvent.prototype)) {\n            const descriptor = Object.getOwnPropertyDescriptor(proto, key)\n            const isFunc = typeof descriptor.value === \"function\"\n            Object.defineProperty(\n                CustomEvent.prototype,\n                key,\n                isFunc\n                    ? defineCallDescriptor(key)\n                    : defineRedirectDescriptor(key)\n            )\n        }\n    }\n\n    return CustomEvent\n}\n\n/**\n * Get the wrapper class of a given prototype.\n * @param {Object} proto The prototype of the original event to get its wrapper.\n * @returns {Function} The wrapper class.\n * @private\n */\nfunction getWrapper(proto) {\n    if (proto == null || proto === Object.prototype) {\n        return Event\n    }\n\n    let wrapper = wrappers.get(proto)\n    if (wrapper == null) {\n        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto)\n        wrappers.set(proto, wrapper)\n    }\n    return wrapper\n}\n\n/**\n * Wrap a given event to management a dispatching.\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Object} event The event to wrap.\n * @returns {Event} The wrapper instance.\n * @private\n */\nexport function wrapEvent(eventTarget, event) {\n    const Wrapper = getWrapper(Object.getPrototypeOf(event))\n    return new Wrapper(eventTarget, event)\n}\n\n/**\n * Get the immediateStopped flag of a given event.\n * @param {Event} event The event to get.\n * @returns {boolean} The flag to stop propagation immediately.\n * @private\n */\nexport function isStopped(event) {\n    return pd(event).immediateStopped\n}\n\n/**\n * Set the current event phase of a given event.\n * @param {Event} event The event to set current target.\n * @param {number} eventPhase New event phase.\n * @returns {void}\n * @private\n */\nexport function setEventPhase(event, eventPhase) {\n    pd(event).eventPhase = eventPhase\n}\n\n/**\n * Set the current target of a given event.\n * @param {Event} event The event to set current target.\n * @param {EventTarget|null} currentTarget New current target.\n * @returns {void}\n * @private\n */\nexport function setCurrentTarget(event, currentTarget) {\n    pd(event).currentTarget = currentTarget\n}\n\n/**\n * Set a passive listener of a given event.\n * @param {Event} event The event to set current target.\n * @param {Function|null} passiveListener New passive listener.\n * @returns {void}\n * @private\n */\nexport function setPassiveListener(event, passiveListener) {\n    pd(event).passiveListener = passiveListener\n}\n","import {\n    isStopped,\n    setCurrentTarget,\n    setEventPhase,\n    setPassiveListener,\n    wrapEvent,\n} from \"./event.mjs\"\n\n/**\n * @typedef {object} ListenerNode\n * @property {Function} listener\n * @property {1|2|3} listenerType\n * @property {boolean} passive\n * @property {boolean} once\n * @property {ListenerNode|null} next\n * @private\n */\n\n/**\n * @type {WeakMap<object, Map<string, ListenerNode>>}\n * @private\n */\nconst listenersMap = new WeakMap()\n\n// Listener types\nconst CAPTURE = 1\nconst BUBBLE = 2\nconst ATTRIBUTE = 3\n\n/**\n * Check whether a given value is an object or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if the value is an object.\n */\nfunction isObject(x) {\n    return x !== null && typeof x === \"object\" //eslint-disable-line no-restricted-syntax\n}\n\n/**\n * Get listeners.\n * @param {EventTarget} eventTarget The event target to get.\n * @returns {Map<string, ListenerNode>} The listeners.\n * @private\n */\nfunction getListeners(eventTarget) {\n    const listeners = listenersMap.get(eventTarget)\n    if (listeners == null) {\n        throw new TypeError(\n            \"'this' is expected an EventTarget object, but got another value.\"\n        )\n    }\n    return listeners\n}\n\n/**\n * Get the property descriptor for the event attribute of a given event.\n * @param {string} eventName The event name to get property descriptor.\n * @returns {PropertyDescriptor} The property descriptor.\n * @private\n */\nfunction defineEventAttributeDescriptor(eventName) {\n    return {\n        get() {\n            const listeners = getListeners(this)\n            let node = listeners.get(eventName)\n            while (node != null) {\n                if (node.listenerType === ATTRIBUTE) {\n                    return node.listener\n                }\n                node = node.next\n            }\n            return null\n        },\n\n        set(listener) {\n            if (typeof listener !== \"function\" && !isObject(listener)) {\n                listener = null // eslint-disable-line no-param-reassign\n            }\n            const listeners = getListeners(this)\n\n            // Traverse to the tail while removing old value.\n            let prev = null\n            let node = listeners.get(eventName)\n            while (node != null) {\n                if (node.listenerType === ATTRIBUTE) {\n                    // Remove old value.\n                    if (prev !== null) {\n                        prev.next = node.next\n                    } else if (node.next !== null) {\n                        listeners.set(eventName, node.next)\n                    } else {\n                        listeners.delete(eventName)\n                    }\n                } else {\n                    prev = node\n                }\n\n                node = node.next\n            }\n\n            // Add new value.\n            if (listener !== null) {\n                const newNode = {\n                    listener,\n                    listenerType: ATTRIBUTE,\n                    passive: false,\n                    once: false,\n                    next: null,\n                }\n                if (prev === null) {\n                    listeners.set(eventName, newNode)\n                } else {\n                    prev.next = newNode\n                }\n            }\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}\n\n/**\n * Define an event attribute (e.g. `eventTarget.onclick`).\n * @param {Object} eventTargetPrototype The event target prototype to define an event attrbite.\n * @param {string} eventName The event name to define.\n * @returns {void}\n */\nfunction defineEventAttribute(eventTargetPrototype, eventName) {\n    Object.defineProperty(\n        eventTargetPrototype,\n        `on${eventName}`,\n        defineEventAttributeDescriptor(eventName)\n    )\n}\n\n/**\n * Define a custom EventTarget with event attributes.\n * @param {string[]} eventNames Event names for event attributes.\n * @returns {EventTarget} The custom EventTarget.\n * @private\n */\nfunction defineCustomEventTarget(eventNames) {\n    /** CustomEventTarget */\n    function CustomEventTarget() {\n        EventTarget.call(this)\n    }\n\n    CustomEventTarget.prototype = Object.create(EventTarget.prototype, {\n        constructor: {\n            value: CustomEventTarget,\n            configurable: true,\n            writable: true,\n        },\n    })\n\n    for (let i = 0; i < eventNames.length; ++i) {\n        defineEventAttribute(CustomEventTarget.prototype, eventNames[i])\n    }\n\n    return CustomEventTarget\n}\n\n/**\n * EventTarget.\n *\n * - This is constructor if no arguments.\n * - This is a function which returns a CustomEventTarget constructor if there are arguments.\n *\n * For example:\n *\n *     class A extends EventTarget {}\n *     class B extends EventTarget(\"message\") {}\n *     class C extends EventTarget(\"message\", \"error\") {}\n *     class D extends EventTarget([\"message\", \"error\"]) {}\n */\nfunction EventTarget() {\n    /*eslint-disable consistent-return */\n    if (this instanceof EventTarget) {\n        listenersMap.set(this, new Map())\n        return\n    }\n    if (arguments.length === 1 && Array.isArray(arguments[0])) {\n        return defineCustomEventTarget(arguments[0])\n    }\n    if (arguments.length > 0) {\n        const types = new Array(arguments.length)\n        for (let i = 0; i < arguments.length; ++i) {\n            types[i] = arguments[i]\n        }\n        return defineCustomEventTarget(types)\n    }\n    throw new TypeError(\"Cannot call a class as a function\")\n    /*eslint-enable consistent-return */\n}\n\n// Should be enumerable, but class methods are not enumerable.\nEventTarget.prototype = {\n    /**\n     * Add a given listener to this event target.\n     * @param {string} eventName The event name to add.\n     * @param {Function} listener The listener to add.\n     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n     * @returns {void}\n     */\n    addEventListener(eventName, listener, options) {\n        if (listener == null) {\n            return\n        }\n        if (typeof listener !== \"function\" && !isObject(listener)) {\n            throw new TypeError(\"'listener' should be a function or an object.\")\n        }\n\n        const listeners = getListeners(this)\n        const optionsIsObj = isObject(options)\n        const capture = optionsIsObj\n            ? Boolean(options.capture)\n            : Boolean(options)\n        const listenerType = capture ? CAPTURE : BUBBLE\n        const newNode = {\n            listener,\n            listenerType,\n            passive: optionsIsObj && Boolean(options.passive),\n            once: optionsIsObj && Boolean(options.once),\n            next: null,\n        }\n\n        // Set it as the first node if the first node is null.\n        let node = listeners.get(eventName)\n        if (node === undefined) {\n            listeners.set(eventName, newNode)\n            return\n        }\n\n        // Traverse to the tail while checking duplication..\n        let prev = null\n        while (node != null) {\n            if (\n                node.listener === listener &&\n                node.listenerType === listenerType\n            ) {\n                // Should ignore duplication.\n                return\n            }\n            prev = node\n            node = node.next\n        }\n\n        // Add it.\n        prev.next = newNode\n    },\n\n    /**\n     * Remove a given listener from this event target.\n     * @param {string} eventName The event name to remove.\n     * @param {Function} listener The listener to remove.\n     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n     * @returns {void}\n     */\n    removeEventListener(eventName, listener, options) {\n        if (listener == null) {\n            return\n        }\n\n        const listeners = getListeners(this)\n        const capture = isObject(options)\n            ? Boolean(options.capture)\n            : Boolean(options)\n        const listenerType = capture ? CAPTURE : BUBBLE\n\n        let prev = null\n        let node = listeners.get(eventName)\n        while (node != null) {\n            if (\n                node.listener === listener &&\n                node.listenerType === listenerType\n            ) {\n                if (prev !== null) {\n                    prev.next = node.next\n                } else if (node.next !== null) {\n                    listeners.set(eventName, node.next)\n                } else {\n                    listeners.delete(eventName)\n                }\n                return\n            }\n\n            prev = node\n            node = node.next\n        }\n    },\n\n    /**\n     * Dispatch a given event.\n     * @param {Event|{type:string}} event The event to dispatch.\n     * @returns {boolean} `false` if canceled.\n     */\n    dispatchEvent(event) {\n        if (event == null || typeof event.type !== \"string\") {\n            throw new TypeError('\"event.type\" should be a string.')\n        }\n\n        // If listeners aren't registered, terminate.\n        const listeners = getListeners(this)\n        const eventName = event.type\n        let node = listeners.get(eventName)\n        if (node == null) {\n            return true\n        }\n\n        // Since we cannot rewrite several properties, so wrap object.\n        const wrappedEvent = wrapEvent(this, event)\n\n        // This doesn't process capturing phase and bubbling phase.\n        // This isn't participating in a tree.\n        let prev = null\n        while (node != null) {\n            // Remove this listener if it's once\n            if (node.once) {\n                if (prev !== null) {\n                    prev.next = node.next\n                } else if (node.next !== null) {\n                    listeners.set(eventName, node.next)\n                } else {\n                    listeners.delete(eventName)\n                }\n            } else {\n                prev = node\n            }\n\n            // Call this listener\n            setPassiveListener(\n                wrappedEvent,\n                node.passive ? node.listener : null\n            )\n            if (typeof node.listener === \"function\") {\n                try {\n                    node.listener.call(this, wrappedEvent)\n                } catch (err) {\n                    if (\n                        typeof console !== \"undefined\" &&\n                        typeof console.error === \"function\"\n                    ) {\n                        console.error(err)\n                    }\n                }\n            } else if (\n                node.listenerType !== ATTRIBUTE &&\n                typeof node.listener.handleEvent === \"function\"\n            ) {\n                node.listener.handleEvent(wrappedEvent)\n            }\n\n            // Break if `event.stopImmediatePropagation` was called.\n            if (isStopped(wrappedEvent)) {\n                break\n            }\n\n            node = node.next\n        }\n        setPassiveListener(wrappedEvent, null)\n        setEventPhase(wrappedEvent, 0)\n        setCurrentTarget(wrappedEvent, null)\n\n        return !wrappedEvent.defaultPrevented\n    },\n}\n\n// `constructor` is not enumerable.\nObject.defineProperty(EventTarget.prototype, \"constructor\", {\n    value: EventTarget,\n    configurable: true,\n    writable: true,\n})\n\n// Ensure `eventTarget instanceof window.EventTarget` is `true`.\nif (\n    typeof window !== \"undefined\" &&\n    typeof window.EventTarget !== \"undefined\"\n) {\n    Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype)\n}\n\nexport { defineEventAttribute, EventTarget }\nexport default EventTarget\n"]}