{"version":3,"sources":["../../src/layouts/shared/SizeCache.ts","../../src/layouts/shared/BaseLayout.ts","../src/layouts/flow.ts"],"names":[],"mappings":"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","file":"flow.d5ea1a85.js","sourceRoot":"../demo","sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nexport interface SizeCacheConfig {\n  roundAverageSize?: boolean;\n}\n\nexport class SizeCache {\n  private _map = new Map<number | string, number>();\n  private _roundAverageSize = false;\n  totalSize = 0;\n\n  constructor(config?: SizeCacheConfig) {\n    if (config?.roundAverageSize === true) {\n      this._roundAverageSize = true;\n    }\n  }\n\n  set(index: number | string, value: number): void {\n    const prev = this._map.get(index) || 0;\n    this._map.set(index, value);\n    this.totalSize += value - prev;\n  }\n\n  get averageSize(): number {\n    if (this._map.size > 0) {\n      const average = this.totalSize / this._map.size;\n      return this._roundAverageSize ? Math.round(average) : average;\n    }\n    return 0;\n  }\n\n  getSize(index: number | string) {\n    return this._map.get(index);\n  }\n\n  clear() {\n    this._map.clear();\n    this.totalSize = 0;\n  }\n}\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {\n  Layout,\n  ChildPositions,\n  Positions,\n  ScrollDirection,\n  Size,\n  dimension,\n  position,\n  PinOptions,\n  ScrollToCoordinates,\n  BaseLayoutConfig,\n  StateChangedMessage,\n  LayoutHostSink,\n} from './Layout.js';\n\ntype UpdateVisibleIndicesOptions = {\n  emit?: boolean;\n};\n\nexport function dim1(direction: ScrollDirection): dimension {\n  return direction === 'horizontal' ? 'width' : 'height';\n}\n\nexport function dim2(direction: ScrollDirection): dimension {\n  return direction === 'horizontal' ? 'height' : 'width';\n}\n\nexport function pos1(direction: ScrollDirection): position {\n  return direction === 'horizontal' ? 'left' : 'top';\n}\n\nexport function pos2(direction: ScrollDirection): position {\n  return direction === 'horizontal' ? 'top' : 'left';\n}\n\nexport abstract class BaseLayout<C extends BaseLayoutConfig> implements Layout {\n  /**\n   * The last set viewport scroll position.\n   */\n  private _latestCoords: Positions = {left: 0, top: 0};\n\n  /**\n   * Scrolling direction.\n   */\n  private _direction: ScrollDirection | null = null;\n\n  /**\n   * Dimensions of the viewport.\n   */\n  private _viewportSize: Size = {width: 0, height: 0};\n\n  public totalScrollSize: Size = {width: 0, height: 0};\n\n  public offsetWithinScroller: Positions = {left: 0, top: 0};\n\n  /**\n   * Flag for debouncing asynchronous reflow requests.\n   */\n  private _pendingReflow = false;\n\n  private _pendingLayoutUpdate = false;\n\n  protected _pin: PinOptions | null = null;\n\n  /**\n   * The index of the first item intersecting the viewport.\n   */\n  protected _firstVisible = 0;\n\n  /**\n   * The index of the last item intersecting the viewport.\n   */\n  protected _lastVisible = 0;\n\n  /**\n   * Pixel offset in the scroll direction of the first child.\n   */\n  protected _physicalMin = 0;\n\n  /**\n   * Pixel offset in the scroll direction of the last child.\n   */\n  protected _physicalMax = 0;\n\n  /**\n   * Index of the first child.\n   */\n  protected _first = -1;\n\n  /**\n   * Index of the last child.\n   */\n  protected _last = -1;\n\n  /**\n   * Length in the scrolling direction.\n   */\n  protected _sizeDim: dimension = 'height';\n\n  /**\n   * Length in the non-scrolling direction.\n   */\n  protected _secondarySizeDim: dimension = 'width';\n\n  /**\n   * Position in the scrolling direction.\n   */\n  protected _positionDim: position = 'top';\n\n  /**\n   * Position in the non-scrolling direction.\n   */\n  protected _secondaryPositionDim: position = 'left';\n\n  /**\n   * Current scroll offset in pixels.\n   */\n  protected _scrollPosition = 0;\n\n  /**\n   * Difference between current scroll offset and scroll offset calculated due\n   * to a reflow.\n   */\n  protected _scrollError = 0;\n\n  /**\n   * Total number of items that could possibly be displayed. Used to help\n   * calculate the scroll size.\n   */\n  protected _items: unknown[] = [];\n\n  /**\n   * The total (estimated) length of all items in the scrolling direction.\n   */\n  protected _scrollSize = 1;\n\n  /**\n   * Number of pixels beyond the viewport to still include\n   * in the active range of items.\n   */\n  // TODO (graynorton): Probably want to make this something we calculate based\n  // on viewport size, item size, other factors, possibly still with a dial of some kind\n  protected _overhang = 1000;\n\n  /**\n   * Call this to deliver messages (e.g. stateChanged, unpinned) to host\n   */\n  private _hostSink: LayoutHostSink;\n\n  protected _getDefaultConfig(): C {\n    return {\n      direction: 'vertical',\n    } as C;\n  }\n\n  constructor(hostSink: LayoutHostSink, config?: C) {\n    this._hostSink = hostSink;\n    // Delay setting config so that subclasses do setup work first\n    Promise.resolve().then(\n      () => (this.config = config || this._getDefaultConfig())\n    );\n  }\n\n  set config(config: C) {\n    Object.assign(this, Object.assign({}, this._getDefaultConfig(), config));\n  }\n\n  get config(): C {\n    return {\n      direction: this.direction,\n    } as C;\n  }\n\n  /**\n   * Maximum index of children + 1, to help estimate total height of the scroll\n   * space.\n   */\n  get items(): unknown[] {\n    return this._items;\n  }\n\n  set items(items: unknown[]) {\n    this._setItems(items);\n  }\n\n  protected _setItems(items: unknown[]) {\n    if (items !== this._items) {\n      this._items = items;\n      this._scheduleReflow();\n    }\n  }\n\n  /**\n   * Primary scrolling direction.\n   */\n  get direction(): ScrollDirection {\n    return this._direction!;\n  }\n  set direction(dir) {\n    // Force it to be either horizontal or vertical.\n    dir = dir === 'horizontal' ? dir : 'vertical';\n    if (dir !== this._direction) {\n      this._direction = dir;\n      this._sizeDim = dir === 'horizontal' ? 'width' : 'height';\n      this._secondarySizeDim = dir === 'horizontal' ? 'height' : 'width';\n      this._positionDim = dir === 'horizontal' ? 'left' : 'top';\n      this._secondaryPositionDim = dir === 'horizontal' ? 'top' : 'left';\n      this._triggerReflow();\n    }\n  }\n\n  /**\n   * Height and width of the viewport.\n   */\n  get viewportSize(): Size {\n    return this._viewportSize;\n  }\n  set viewportSize(dims) {\n    const {_viewDim1, _viewDim2} = this;\n    Object.assign(this._viewportSize, dims);\n    if (_viewDim2 !== this._viewDim2) {\n      // this._viewDim2Changed();\n      this._scheduleLayoutUpdate();\n    } else if (_viewDim1 !== this._viewDim1) {\n      this._checkThresholds();\n    }\n  }\n\n  /**\n   * Scroll offset of the viewport.\n   */\n  get viewportScroll(): Positions {\n    return this._latestCoords;\n  }\n  set viewportScroll(coords) {\n    Object.assign(this._latestCoords, coords);\n    const oldPos = this._scrollPosition;\n    this._scrollPosition = this._latestCoords[this._positionDim];\n    const change = Math.abs(oldPos - this._scrollPosition);\n    if (change >= 1) {\n      this._checkThresholds();\n    }\n  }\n\n  /**\n   * Perform a reflow if one has been scheduled.\n   */\n  reflowIfNeeded(force = false) {\n    if (force || this._pendingReflow) {\n      this._pendingReflow = false;\n      this._reflow();\n    }\n  }\n\n  set pin(options: PinOptions | null) {\n    this._pin = options;\n    this._triggerReflow();\n  }\n\n  get pin() {\n    if (this._pin !== null) {\n      const {index, block} = this._pin;\n      return {\n        index: Math.max(0, Math.min(index, this.items.length - 1)),\n        block,\n      };\n    }\n    return null;\n  }\n\n  _clampScrollPosition(val: number) {\n    return Math.max(\n      -this.offsetWithinScroller[this._positionDim],\n      Math.min(val, this.totalScrollSize[dim1(this.direction)] - this._viewDim1)\n    );\n  }\n\n  unpin() {\n    if (this._pin !== null) {\n      this._sendUnpinnedMessage();\n      this._pin = null;\n    }\n  }\n\n  /**\n   * Get the top and left positioning of the item at idx.\n   */\n  protected abstract _getItemPosition(idx: number): Positions;\n\n  /**\n   * Update _first and _last based on items that should be in the current\n   * range.\n   */\n  protected abstract _getActiveItems(): void;\n\n  protected abstract _getItemSize(_idx: number): Size;\n\n  /**\n   * Calculates (precisely or by estimating, if needed) the total length of all items in\n   * the scrolling direction, including spacing, caching the value in the `_scrollSize` field.\n   *\n   * Should return a minimum value of 1 to ensure at least one item is rendered.\n   * TODO (graynorton): Possibly no longer required, but leaving here until it can be verified.\n   */\n  protected abstract _updateScrollSize(): void;\n\n  protected _updateLayout(): void {\n    // Override\n  }\n\n  // protected _viewDim2Changed(): void {\n  //   this._scheduleLayoutUpdate();\n  // }\n\n  /**\n   * The height or width of the viewport, whichever corresponds to the scrolling direction.\n   */\n  protected get _viewDim1(): number {\n    return this._viewportSize[this._sizeDim];\n  }\n\n  /**\n   * The height or width of the viewport, whichever does NOT correspond to the scrolling direction.\n   */\n  protected get _viewDim2(): number {\n    return this._viewportSize[this._secondarySizeDim];\n  }\n\n  protected _scheduleReflow() {\n    this._pendingReflow = true;\n  }\n\n  protected _scheduleLayoutUpdate() {\n    this._pendingLayoutUpdate = true;\n    this._scheduleReflow();\n  }\n\n  // For triggering a reflow based on incoming changes to\n  // the layout config.\n  protected _triggerReflow() {\n    this._scheduleLayoutUpdate();\n    // TODO graynorton@: reflowIfNeeded() isn't really supposed\n    // to be called internally. Address in larger cleanup\n    // of virtualizer / layout interaction pattern.\n    // this.reflowIfNeeded(true);\n    Promise.resolve().then(() => this.reflowIfNeeded());\n  }\n\n  protected _reflow() {\n    if (this._pendingLayoutUpdate) {\n      this._updateLayout();\n      this._pendingLayoutUpdate = false;\n    }\n    this._updateScrollSize();\n    this._setPositionFromPin();\n    this._getActiveItems();\n    this._updateVisibleIndices();\n    this._sendStateChangedMessage();\n  }\n\n  /**\n   * If we are supposed to be pinned to a particular\n   * item or set of coordinates, we set `_scrollPosition`\n   * accordingly and adjust `_scrollError` as needed\n   * so that the virtualizer can keep the scroll\n   * position in the DOM in sync\n   */\n  protected _setPositionFromPin() {\n    if (this.pin !== null) {\n      const lastScrollPosition = this._scrollPosition;\n      const {index, block} = this.pin;\n      this._scrollPosition =\n        this._calculateScrollIntoViewPosition({\n          index,\n          block: block || 'start',\n        }) - this.offsetWithinScroller[this._positionDim];\n      this._scrollError = lastScrollPosition - this._scrollPosition;\n    }\n  }\n  /**\n   * Calculate the coordinates to scroll to, given\n   * a request to scroll to the element at a specific\n   * index.\n   *\n   * Supports the same positioning options (`start`,\n   * `center`, `end`, `nearest`) as the standard\n   * `Element.scrollIntoView()` method, but currently\n   * only considers the provided value in the `block`\n   * dimension, since we don't yet have any layouts\n   * that support virtualization in two dimensions.\n   */\n  protected _calculateScrollIntoViewPosition(options: PinOptions) {\n    const {block} = options;\n    const index = Math.min(this.items.length, Math.max(0, options.index));\n    const itemStartPosition = this._getItemPosition(index)[this._positionDim];\n    let scrollPosition = itemStartPosition;\n    if (block !== 'start') {\n      const itemSize = this._getItemSize(index)[this._sizeDim];\n      if (block === 'center') {\n        scrollPosition =\n          itemStartPosition - 0.5 * this._viewDim1 + 0.5 * itemSize;\n      } else {\n        const itemEndPosition = itemStartPosition - this._viewDim1 + itemSize;\n        if (block === 'end') {\n          scrollPosition = itemEndPosition;\n        } else {\n          // block === 'nearest'\n          const currentScrollPosition = this._scrollPosition;\n          scrollPosition =\n            Math.abs(currentScrollPosition - itemStartPosition) <\n            Math.abs(currentScrollPosition - itemEndPosition)\n              ? itemStartPosition\n              : itemEndPosition;\n        }\n      }\n    }\n    scrollPosition += this.offsetWithinScroller[this._positionDim];\n    return this._clampScrollPosition(scrollPosition);\n  }\n\n  public getScrollIntoViewCoordinates(\n    options: PinOptions\n  ): ScrollToCoordinates {\n    return {\n      [this._positionDim as position]:\n        this._calculateScrollIntoViewPosition(options),\n    } as ScrollToOptions;\n  }\n\n  private _sendUnpinnedMessage() {\n    this._hostSink({\n      type: 'unpinned',\n    });\n  }\n\n  private _sendVisibilityChangedMessage() {\n    this._hostSink({\n      type: 'visibilityChanged',\n      firstVisible: this._firstVisible,\n      lastVisible: this._lastVisible,\n    });\n  }\n\n  protected _sendStateChangedMessage() {\n    const childPositions: ChildPositions = new Map();\n    if (this._first !== -1 && this._last !== -1) {\n      for (let idx = this._first; idx <= this._last; idx++) {\n        childPositions.set(idx, this._getItemPosition(idx));\n      }\n    }\n    const message: StateChangedMessage = {\n      type: 'stateChanged',\n      scrollSize: {\n        [this._sizeDim]: this._scrollSize,\n        [this._secondarySizeDim]: null,\n      } as Size,\n      range: {\n        first: this._first,\n        last: this._last,\n        firstVisible: this._firstVisible,\n        lastVisible: this._lastVisible,\n      },\n      childPositions,\n    };\n    if (this._scrollError) {\n      message.scrollError = {\n        [this._positionDim]: this._scrollError,\n        [this._secondaryPositionDim]: 0,\n      } as Positions;\n      this._scrollError = 0;\n    }\n    this._hostSink(message);\n  }\n\n  /**\n   * Number of items to display.\n   */\n  private get _num(): number {\n    if (this._first === -1 || this._last === -1) {\n      return 0;\n    }\n    return this._last - this._first + 1;\n  }\n\n  private _checkThresholds() {\n    if ((this._viewDim1 === 0 && this._num > 0) || this._pin !== null) {\n      this._scheduleReflow();\n    } else {\n      const min = Math.max(0, this._scrollPosition - this._overhang);\n      const max = Math.min(\n        this._scrollSize,\n        this._scrollPosition + this._viewDim1 + this._overhang\n      );\n      if (this._physicalMin > min || this._physicalMax < max) {\n        this._scheduleReflow();\n      } else {\n        this._updateVisibleIndices({emit: true});\n      }\n    }\n  }\n\n  /**\n   * Find the indices of the first and last items to intersect the viewport.\n   * Emit a visibleindiceschange event when either index changes.\n   */\n  protected _updateVisibleIndices(options?: UpdateVisibleIndicesOptions) {\n    if (this._first === -1 || this._last === -1) return;\n\n    let firstVisible = this._first;\n    while (\n      firstVisible < this._last &&\n      Math.round(\n        this._getItemPosition(firstVisible)[this._positionDim] +\n          this._getItemSize(firstVisible)[this._sizeDim]\n      ) <= Math.round(this._scrollPosition)\n    ) {\n      firstVisible++;\n    }\n\n    let lastVisible = this._last;\n    while (\n      lastVisible > this._first &&\n      Math.round(this._getItemPosition(lastVisible)[this._positionDim]) >=\n        Math.round(this._scrollPosition + this._viewDim1)\n    ) {\n      lastVisible--;\n    }\n\n    if (\n      firstVisible !== this._firstVisible ||\n      lastVisible !== this._lastVisible\n    ) {\n      this._firstVisible = firstVisible;\n      this._lastVisible = lastVisible;\n      if (options && options.emit) {\n        this._sendVisibilityChangedMessage();\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {SizeCache} from './shared/SizeCache.js';\nimport {BaseLayout, dim1} from './shared/BaseLayout.js';\nimport {\n  Positions,\n  Size,\n  Margins,\n  margin,\n  ScrollDirection,\n  offsetAxis,\n  ChildMeasurements,\n  BaseLayoutConfig,\n  LayoutHostSink,\n} from './shared/Layout.js';\n\ntype ItemBounds = {\n  pos: number;\n  size: number;\n};\n\ntype FlowLayoutConstructor = {\n  prototype: FlowLayout;\n  new (hostSink: LayoutHostSink, config?: BaseLayoutConfig): FlowLayout;\n};\n\ntype FlowLayoutSpecifier = BaseLayoutConfig & {\n  type: FlowLayoutConstructor;\n};\n\ntype FlowLayoutSpecifierFactory = (\n  config?: BaseLayoutConfig\n) => FlowLayoutSpecifier;\n\nexport const flow: FlowLayoutSpecifierFactory = (config?: BaseLayoutConfig) =>\n  Object.assign(\n    {\n      type: FlowLayout,\n    },\n    config\n  );\n\nfunction leadingMargin(direction: ScrollDirection): margin {\n  return direction === 'horizontal' ? 'marginLeft' : 'marginTop';\n}\n\nfunction trailingMargin(direction: ScrollDirection): margin {\n  return direction === 'horizontal' ? 'marginRight' : 'marginBottom';\n}\n\nfunction offset(direction: ScrollDirection): offsetAxis {\n  return direction === 'horizontal' ? 'xOffset' : 'yOffset';\n}\n\nfunction collapseMargins(a: number, b: number): number {\n  const m = [a, b].sort();\n  return m[1] <= 0 ? Math.min(...m) : m[0] >= 0 ? Math.max(...m) : m[0] + m[1];\n}\n\nclass MetricsCache {\n  private _childSizeCache = new SizeCache();\n  private _marginSizeCache = new SizeCache();\n  private _metricsCache = new Map<number, Size & Margins>();\n\n  update(metrics: {[key: number]: Size & Margins}, direction: ScrollDirection) {\n    const marginsToUpdate = new Set<number>();\n    Object.keys(metrics).forEach((key) => {\n      const k = Number(key);\n      this._metricsCache.set(k, metrics[k]);\n      this._childSizeCache.set(k, metrics[k][dim1(direction)]);\n      marginsToUpdate.add(k);\n      marginsToUpdate.add(k + 1);\n    });\n    for (const k of marginsToUpdate) {\n      const a = this._metricsCache.get(k)?.[leadingMargin(direction)] || 0;\n      const b = this._metricsCache.get(k - 1)?.[trailingMargin(direction)] || 0;\n      this._marginSizeCache.set(k, collapseMargins(a, b));\n    }\n  }\n\n  get averageChildSize(): number {\n    return this._childSizeCache.averageSize;\n  }\n\n  get totalChildSize(): number {\n    return this._childSizeCache.totalSize;\n  }\n\n  get averageMarginSize(): number {\n    return this._marginSizeCache.averageSize;\n  }\n\n  get totalMarginSize(): number {\n    return this._marginSizeCache.totalSize;\n  }\n\n  getLeadingMarginValue(index: number, direction: ScrollDirection) {\n    return this._metricsCache.get(index)?.[leadingMargin(direction)] || 0;\n  }\n\n  getChildSize(index: number) {\n    return this._childSizeCache.getSize(index);\n  }\n\n  getMarginSize(index: number) {\n    return this._marginSizeCache.getSize(index);\n  }\n\n  clear() {\n    this._childSizeCache.clear();\n    this._marginSizeCache.clear();\n    this._metricsCache.clear();\n  }\n}\n\nexport class FlowLayout extends BaseLayout<BaseLayoutConfig> {\n  /**\n   * Initial estimate of item size\n   */\n  _itemSize: Size = {width: 100, height: 100};\n\n  /**\n   * Indices of children mapped to their (position and length) in the scrolling\n   * direction. Used to keep track of children that are in range.\n   */\n  _physicalItems = new Map<number, ItemBounds>();\n\n  /**\n   * Used in tandem with _physicalItems to track children in range across\n   * reflows.\n   */\n  _newPhysicalItems = new Map<number, ItemBounds>();\n\n  /**\n   * Width and height of children by their index.\n   */\n  _metricsCache = new MetricsCache();\n\n  /**\n   * anchorIdx is the anchor around which we reflow. It is designed to allow\n   * jumping to any point of the scroll size. We choose it once and stick with\n   * it until stable. _first and _last are deduced around it.\n   */\n  _anchorIdx: number | null = null;\n\n  /**\n   * Position in the scrolling direction of the anchor child.\n   */\n  _anchorPos: number | null = null;\n\n  /**\n   * Whether all children in range were in range during the previous reflow.\n   */\n  _stable = true;\n\n  private _measureChildren = true;\n\n  _estimate = true;\n\n  // protected _defaultConfig: BaseLayoutConfig = Object.assign({}, super._defaultConfig, {\n\n  // })\n\n  // constructor(config: Layout1dConfig) {\n  //   super(config);\n  // }\n\n  get measureChildren() {\n    return this._measureChildren;\n  }\n\n  /**\n   * Determine the average size of all children represented in the sizes\n   * argument.\n   */\n  updateItemSizes(sizes: ChildMeasurements) {\n    this._metricsCache.update(sizes as Size & Margins, this.direction);\n    // if (this._nMeasured) {\n    // this._updateItemSize();\n    this._scheduleReflow();\n    // }\n  }\n\n  /**\n   * Set the average item size based on the total length and number of children\n   * in range.\n   */\n  // _updateItemSize() {\n  //   // Keep integer values.\n  //   this._itemSize[this._sizeDim] = this._metricsCache.averageChildSize;\n  // }\n\n  _getPhysicalItem(idx: number): ItemBounds | undefined {\n    return this._newPhysicalItems.get(idx) ?? this._physicalItems.get(idx);\n  }\n\n  _getSize(idx: number): number | undefined {\n    const item = this._getPhysicalItem(idx);\n    return item && this._metricsCache.getChildSize(idx);\n  }\n\n  _getAverageSize(): number {\n    return this._metricsCache.averageChildSize || this._itemSize[this._sizeDim];\n  }\n\n  _estimatePosition(idx: number): number {\n    const c = this._metricsCache;\n    if (this._first === -1 || this._last === -1) {\n      return (\n        c.averageMarginSize +\n        idx * (c.averageMarginSize + this._getAverageSize())\n      );\n    } else {\n      if (idx < this._first) {\n        const delta = this._first - idx;\n        const refItem = this._getPhysicalItem(this._first);\n        return (\n          refItem!.pos -\n          (c.getMarginSize(this._first - 1) || c.averageMarginSize) -\n          (delta * c.averageChildSize + (delta - 1) * c.averageMarginSize)\n        );\n      } else {\n        const delta = idx - this._last;\n        const refItem = this._getPhysicalItem(this._last);\n        return (\n          refItem!.pos +\n          (c.getChildSize(this._last) || c.averageChildSize) +\n          (c.getMarginSize(this._last) || c.averageMarginSize) +\n          delta * (c.averageChildSize + c.averageMarginSize)\n        );\n      }\n    }\n  }\n\n  /**\n   * Returns the position in the scrolling direction of the item at idx.\n   * Estimates it if the item at idx is not in the DOM.\n   */\n  _getPosition(idx: number): number {\n    const item = this._getPhysicalItem(idx);\n    const {averageMarginSize} = this._metricsCache;\n    return idx === 0\n      ? this._metricsCache.getMarginSize(0) ?? averageMarginSize\n      : item\n      ? item.pos\n      : this._estimatePosition(idx);\n  }\n\n  _calculateAnchor(lower: number, upper: number): number {\n    if (lower <= 0) {\n      return 0;\n    }\n    if (upper > this._scrollSize - this._viewDim1) {\n      return this.items.length - 1;\n    }\n    return Math.max(\n      0,\n      Math.min(\n        this.items.length - 1,\n        Math.floor((lower + upper) / 2 / this._delta)\n      )\n    );\n  }\n\n  _getAnchor(lower: number, upper: number): number {\n    if (this._physicalItems.size === 0) {\n      return this._calculateAnchor(lower, upper);\n    }\n    if (this._first < 0) {\n      return this._calculateAnchor(lower, upper);\n    }\n    if (this._last < 0) {\n      return this._calculateAnchor(lower, upper);\n    }\n\n    const firstItem = this._getPhysicalItem(this._first),\n      lastItem = this._getPhysicalItem(this._last),\n      firstMin = firstItem!.pos,\n      lastMin = lastItem!.pos,\n      lastMax = lastMin + this._metricsCache.getChildSize(this._last)!;\n\n    if (lastMax < lower) {\n      // Window is entirely past physical items, calculate new anchor\n      return this._calculateAnchor(lower, upper);\n    }\n    if (firstMin > upper) {\n      // Window is entirely before physical items, calculate new anchor\n      return this._calculateAnchor(lower, upper);\n    }\n    // Window contains a physical item\n    // Find one, starting with the one that was previously first visible\n    let candidateIdx = this._firstVisible - 1;\n    let cMax = -Infinity;\n    while (cMax < lower) {\n      const candidate = this._getPhysicalItem(++candidateIdx);\n      cMax = candidate!.pos + this._metricsCache.getChildSize(candidateIdx)!;\n    }\n    return candidateIdx;\n  }\n\n  /**\n   * Updates _first and _last based on items that should be in the current\n   * viewed range.\n   */\n  _getActiveItems() {\n    if (this._viewDim1 === 0 || this.items.length === 0) {\n      this._clearItems();\n    } else {\n      this._getItems();\n    }\n  }\n\n  /**\n   * Sets the range to empty.\n   */\n  _clearItems() {\n    this._first = -1;\n    this._last = -1;\n    this._physicalMin = 0;\n    this._physicalMax = 0;\n    const items = this._newPhysicalItems;\n    this._newPhysicalItems = this._physicalItems;\n    this._newPhysicalItems.clear();\n    this._physicalItems = items;\n    this._stable = true;\n  }\n\n  /*\n   * Updates _first and _last based on items that should be in the given range.\n   */\n  _getItems() {\n    const items = this._newPhysicalItems;\n    this._stable = true;\n    let lower, upper;\n\n    // The anchorIdx is the anchor around which we reflow. It is designed to\n    // allow jumping to any point of the scroll size. We choose it once and\n    // stick with it until stable. first and last are deduced around it.\n\n    // If we have a pinned item, we anchor on it\n    if (this.pin !== null) {\n      const {index} = this.pin;\n      this._anchorIdx = index;\n      this._anchorPos = this._getPosition(index);\n    }\n\n    // Determine the lower and upper bounds of the region to be\n    // rendered, relative to the viewport\n    lower = this._scrollPosition - this._overhang; //leadingOverhang;\n    upper = this._scrollPosition + this._viewDim1 + this._overhang; // trailingOverhang;\n\n    if (upper < 0 || lower > this._scrollSize) {\n      this._clearItems();\n      return;\n    }\n\n    // If we are scrolling to a specific index or if we are doing another\n    // pass to stabilize a previously started reflow, we will already\n    // have an anchor. If not, establish an anchor now.\n    if (this._anchorIdx === null || this._anchorPos === null) {\n      this._anchorIdx = this._getAnchor(lower, upper);\n      this._anchorPos = this._getPosition(this._anchorIdx);\n    }\n\n    let anchorSize = this._getSize(this._anchorIdx);\n    if (anchorSize === undefined) {\n      this._stable = false;\n      anchorSize = this._getAverageSize();\n    }\n\n    const anchorLeadingMargin =\n      this._metricsCache.getMarginSize(this._anchorIdx) ??\n      this._metricsCache.averageMarginSize;\n    const anchorTrailingMargin =\n      this._metricsCache.getMarginSize(this._anchorIdx + 1) ??\n      this._metricsCache.averageMarginSize;\n\n    if (this._anchorIdx === 0) {\n      this._anchorPos = anchorLeadingMargin;\n    }\n\n    if (this._anchorIdx === this.items.length - 1) {\n      this._anchorPos = this._scrollSize - anchorTrailingMargin - anchorSize;\n    }\n\n    // Anchor might be outside bounds, so prefer correcting the error and keep\n    // that anchorIdx.\n    let anchorErr = 0;\n\n    if (this._anchorPos + anchorSize + anchorTrailingMargin < lower) {\n      anchorErr = lower - (this._anchorPos + anchorSize + anchorTrailingMargin);\n    }\n\n    if (this._anchorPos - anchorLeadingMargin > upper) {\n      anchorErr = upper - (this._anchorPos - anchorLeadingMargin);\n    }\n\n    if (anchorErr) {\n      this._scrollPosition -= anchorErr;\n      lower -= anchorErr;\n      upper -= anchorErr;\n      this._scrollError += anchorErr;\n    }\n\n    items.set(this._anchorIdx, {pos: this._anchorPos, size: anchorSize});\n\n    this._first = this._last = this._anchorIdx;\n    this._physicalMin = this._anchorPos - anchorLeadingMargin;\n    this._physicalMax = this._anchorPos + anchorSize + anchorTrailingMargin;\n\n    while (this._physicalMin > lower && this._first > 0) {\n      let size = this._getSize(--this._first);\n      if (size === undefined) {\n        this._stable = false;\n        size = this._getAverageSize();\n      }\n      let margin = this._metricsCache.getMarginSize(this._first);\n      if (margin === undefined) {\n        this._stable = false;\n        margin = this._metricsCache.averageMarginSize;\n      }\n      this._physicalMin -= size;\n      const pos = this._physicalMin;\n      items.set(this._first, {pos, size});\n      this._physicalMin -= margin;\n      if (this._stable === false && this._estimate === false) {\n        break;\n      }\n    }\n\n    while (this._physicalMax < upper && this._last < this.items.length - 1) {\n      let size = this._getSize(++this._last);\n      if (size === undefined) {\n        this._stable = false;\n        size = this._getAverageSize();\n      }\n      let margin = this._metricsCache.getMarginSize(this._last);\n      if (margin === undefined) {\n        this._stable = false;\n        margin = this._metricsCache.averageMarginSize;\n      }\n      const pos = this._physicalMax;\n      items.set(this._last, {pos, size});\n      this._physicalMax += size + margin;\n      if (!this._stable && !this._estimate) {\n        break;\n      }\n    }\n\n    // This handles the cases where we were relying on estimated sizes.\n    const extentErr = this._calculateError();\n    if (extentErr) {\n      this._physicalMin -= extentErr;\n      this._physicalMax -= extentErr;\n      this._anchorPos -= extentErr;\n      this._scrollPosition -= extentErr;\n      items.forEach((item) => (item.pos -= extentErr));\n      this._scrollError += extentErr;\n    }\n\n    if (this._stable) {\n      this._newPhysicalItems = this._physicalItems;\n      this._newPhysicalItems.clear();\n      this._physicalItems = items;\n    }\n  }\n\n  _calculateError(): number {\n    if (this._first === 0) {\n      return this._physicalMin;\n    } else if (this._physicalMin <= 0) {\n      return this._physicalMin - this._first * this._delta;\n    } else if (this._last === this.items.length - 1) {\n      return this._physicalMax - this._scrollSize;\n    } else if (this._physicalMax >= this._scrollSize) {\n      return (\n        this._physicalMax -\n        this._scrollSize +\n        (this.items.length - 1 - this._last) * this._delta\n      );\n    }\n    return 0;\n  }\n\n  override _reflow() {\n    const {_first, _last} = this;\n    super._reflow();\n    if (\n      (this._first === -1 && this._last == -1) ||\n      (this._first === _first && this._last === _last)\n    ) {\n      this._resetReflowState();\n    }\n  }\n\n  _resetReflowState() {\n    this._anchorIdx = null;\n    this._anchorPos = null;\n    this._stable = true;\n  }\n\n  _updateScrollSize() {\n    const {averageMarginSize} = this._metricsCache;\n    this._scrollSize = Math.max(\n      1,\n      this.items.length * (averageMarginSize + this._getAverageSize()) +\n        averageMarginSize\n    );\n  }\n\n  /**\n   * Returns the average size (precise or estimated) of an item in the scrolling direction,\n   * including any surrounding space.\n   */\n  protected get _delta(): number {\n    const {averageMarginSize} = this._metricsCache;\n    return this._getAverageSize() + averageMarginSize;\n  }\n\n  /**\n   * Returns the top and left positioning of the item at idx.\n   */\n  _getItemPosition(idx: number): Positions {\n    return {\n      [this._positionDim]: this._getPosition(idx),\n      [this._secondaryPositionDim]: 0,\n      [offset(this.direction)]: -(\n        this._metricsCache.getLeadingMarginValue(idx, this.direction) ??\n        this._metricsCache.averageMarginSize\n      ),\n    } as Positions;\n  }\n\n  /**\n   * Returns the height and width of the item at idx.\n   */\n  _getItemSize(idx: number): Size {\n    return {\n      [this._sizeDim]: this._getSize(idx) || this._getAverageSize(),\n      [this._secondarySizeDim]: this._itemSize[this._secondarySizeDim],\n    } as Size;\n  }\n\n  _viewDim2Changed() {\n    this._metricsCache.clear();\n    this._scheduleReflow();\n  }\n}\n"]}